<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8"/>
        <title>Classic Stroop</title>
        <script src="https://code.jquery.com/jquery-3.7.1.js" 
                integrity="sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4=" 
                crossorigin="anonymous"></script>
    </head>
    <body>
        <center>
            <div>
                <p>Classic Stroop!</p>
                <canvas id="experiment" width=1000px height=700px></canvas>
            </div>
        </center>

        <style>
            #experiment {
                border: 2px solid white;
                background-color: black; 
            }
        </style>

<script  type="module">
    import { exportCSV } from "./exportCSV.js";
    const participantId = localStorage.getItem("participantId");
    var colorWords = ["red", "green", "blue","yellow", "purple", "brown", "black", "pink"];
    var neutralWords = ["bike", "window", "door", "book", "tree", "car", "dog", "cat"];
    var colors = ["#FF0000", "#00FF00", "#0000FF"];
    const colorMap = { "#FF0000":"R", "#00FF00":"G", "#0000FF":"B" };
    const labelsOrder = "RGB";
    var trials = 2;
    var sessions = 2;
    var sessionNum = 0;
    let results = [];
    const demoTrials = [{word: "red", color: colors[0]},
     {word: "blue", color: colors[1]},
     {word: "tree", color: colors[2]},
     {word: "green", color: colors[0]},
     {word: "door", color: colors[1]},
     {word: "blue", color: colors[2]}] //determined trials for the demo (2 of each type)

    function getRandom(){
        let StimType = Math.floor(Math.random()*3),
            StimulusWord, StimulusColor, Stimulus;

        if (StimType === 0) {
            let idx = Math.floor(Math.random()*3);
            StimulusWord  = colorWords[idx];
            StimulusColor = colors[idx];
            Stimulus = "congruent";
        }
        else if (StimType === 1) {
            let idx1 = Math.floor(Math.random()*colorWords.length),
                idx2 = Math.floor(Math.random()*3);
            while (idx1 === idx2) {
                idx2 = Math.floor(Math.random()*3);
            }
            StimulusWord  = colorWords[idx1];
            StimulusColor = colors[idx2];
            Stimulus = "incongruent";
        }
        else {
            let idx1 = Math.floor(Math.random()*neutralWords.length),
                idx2 = Math.floor(Math.random()*3);
            StimulusWord  = neutralWords[idx1];
            StimulusColor = colors[idx2];
            Stimulus = "neutral";
        }
        return [StimulusWord, StimulusColor, Stimulus];
    }

    function endSession(){
        clearCanvas();
        setTimeout(() => {
            writeText("press Spacebar to continue");
            $(document).off('keydown.waitForSpace');

            $(document).on('keydown.waitForSpace', function onKey(e) {
            const isSpace = (e.keyCode === 32);
            if (!isSpace) return; 

            $(document).off('keydown.waitForSpace');
        
                if (sessionNum >= sessions) {
                    exportCSV(results, "classic_stroop.csv");
                    clearCanvas();
                    writeText("You finished the task. Thank you!");
                    setTimeout(() => {
                        window.location.href = "qualtrics.html";
                    }, 2000); // 2 seconds delay
                } else {
                    runSession();
                } 
            });
        }, 1500); // 1 second delay
    }


    async function runTrial(durationMs) {

        const trialState = { timeoutId: null, keyListener: null };
        const TrialStart = performance.now(); //timer

        function cleanup() {
            if (trialState.timeoutId !== null) {
                clearTimeout(trialState.timeoutId);
                trialState.timeoutId = null;
            }
            if (trialState.keyListener !== null) {
                document.removeEventListener('keydown', trialState.keyListener);
                trialState.keyListener = null;
            }
        }

        //if no response
        const timeoutPromise = new Promise(resolve => {
            trialState.timeoutId = setTimeout(() => {
                cleanup();
                resolve({ reason: 'timeout' });
            }, durationMs);
        });

        //if response
        const keyPromise = new Promise(resolve => {
            trialState.keyListener = function(e) {
                cleanup();
                const ReactionTime = performance.now() - TrialStart; //measures reaction time
                resolve({ reason: 'keypress', key: e.key, ReactionTime });

            };
            document.addEventListener('keydown', trialState.keyListener);
        });

        return await Promise.race([ timeoutPromise, keyPromise ]);
    }

    async function runSession() {
        
        sessionNum++;
        for (let trialNum = 0; trialNum < trials; trialNum++) {

            clearCanvas();
            const [word, color, type] = getRandom();
            writeText(word, color);

            const result = await runTrial(2000);
            let feedbackWord;
            if (result.reason === 'keypress') {
                const pressed = (result.key || "").toUpperCase();
                const expectedKey =
                    (color === colors[0]) ? "R" :
                    (color === colors[1]) ? "G" :
                    (color === colors[2]) ? "B" : "";
                
                const isCorrect = (pressed === expectedKey);
                
                feedbackWord = isCorrect ? "Right!" : "Wrong!";
                
                results.push({
                    ID: participantId,
                    session: sessionNum,
                    trial: trialNum + 1,             
                    condition: type,                 
                    word: word.toUpperCase(),
                    ink_color:  (color === colors[0]) ? "red" :
                                (color === colors[1]) ? "green" :
                                (color === colors[2]) ? "blue" : "",
                    labels_order: "RGB",
                    correct_label: expectedKey,
                    response_label: pressed,
                    rt_ms: Math.round(result.ReactionTime || 0),
                    accuracy: isCorrect ? 1 : 0,
                    final_grade: isCorrect ? 1 : 0,
                    outcome: "response",
                    timestamp: new Date().toISOString()
                });
                
                clearCanvas();
                writeText(feedbackWord);
                await new Promise(r => setTimeout(r, 500));
                clearCanvas();
                writeText("+");
                await new Promise(r => setTimeout(r, 500));
            } else {
                    results.push({
                        ID: participantId,
                        session: sessionNum,
                        trial: trialNum + 1,
                        condition: type,
                        word: word.toUpperCase(),
                        ink_color:  (color === colors[0]) ? "red" :
                                    (color === colors[1]) ? "green" :
                                    (color === colors[2]) ? "blue" : "",
                        labels_order: "RGB",
                        correct_label:
                                    (color === colors[0]) ? "R" :
                                    (color === colors[1]) ? "G" :
                                    (color === colors[2]) ? "B" : "",
                        response_label: "NR",
                        rt_ms: null,
                        accuracy: 0,
                        final_grade: -1,
                        outcome: "no_response_timeout",
                        timestamp: new Date().toISOString()
                    });
                clearCanvas();
                writeText("+");
                await new Promise(r => setTimeout(r, 500));
            }
        }
        endSession();
    }

    async function runDemoSession() {
        for (let i = 0; i < 3; i++){
            const { word, color } = demoTrials[i];
            const txt = "In this example, the color of the word is: " + colorWords[i] + ".";
            const instruc = "Therefore, press " + colorWords[i][0].toUpperCase() + " for the right response.";
            const lines = [txt, instruc, word];
            const lineColor = ["#FFFFFF", "#FFFFFF", color];
            const lineFont = ["bold 40px Arial", "bold 40px Arial", "bold 48px Arial"]
            const lineHeight = 50; 
            const startY = window.canvas.height/2 - (2 * lineHeight);
            const expectedKey =
                color === colors[0] ? "r" :
                color === colors[1] ? "g" :
                color === colors[2] ? "b" : "" ;
            
            let correct = false;

            while (!correct){
                clearCanvas();
                lines.forEach((text, j) => {
                    window.ctx.fillStyle = lineColor[j]
                    window.ctx.font = lineFont[j];
                    window.ctx.textAlign = "center";
                    window.ctx.fillText(
                    text,
                    window.canvas.width/2,
                    startY + j * lineHeight
                    );
                });
                const result = await runTrial(15000);

                if (result.reason !== 'keypress') {
                    clearCanvas();
                    writeText( "Try again.");
                    await new Promise(r => setTimeout(r, 1000));
                    clearCanvas();
                    writeText("+");
                    await new Promise(r => setTimeout(r, 500));
                    continue; 
                }

                const key = (result.key || "").toLowerCase();
                correct = key === expectedKey;

                if (!correct){
                    clearCanvas();
                    writeText( "wrong answer, Try again.");
                    await new Promise(r => setTimeout(r, 2000));
                } else {
                    clearCanvas();
                    writeText( "Right!");
                    await new Promise(r => setTimeout(r, 1000));
                }

                clearCanvas();
                writeText("+");
                await new Promise(r => setTimeout(r, 500));
            }  
        }

        for (let i = 3; i < demoTrials.length; i++) {
            const { word, color } = demoTrials[i];
            const expectedKey =
                color === colors[0] ? "r" :
                color === colors[1] ? "g" :
                color === colors[2] ? "b" : "" ;
            
            let correct = false;

            while (!correct){
                clearCanvas();
                writeText(word, color);
                const result = await runTrial(2000);

                if (result.reason !== 'keypress') {
                    clearCanvas();
                    writeText( "Try again.");
                    await new Promise(r => setTimeout(r, 1000));
                    clearCanvas();
                    writeText("+");
                    await new Promise(r => setTimeout(r, 500));
                    continue; 
                }

                const key = (result.key || "").toLowerCase();
                correct = key === expectedKey;

                if (!correct){
                    clearCanvas();
                    writeText( "wrong answer, Try again.");
                    await new Promise(r => setTimeout(r, 2000));
                } else {
                    clearCanvas();
                    writeText( "Right!");
                    await new Promise(r => setTimeout(r, 1000));
                }

                clearCanvas();
                writeText("+");
                await new Promise(r => setTimeout(r, 500));
            } 
        endDemoSession();
        }
    }

    function endDemoSession() {
        clearCanvas();
        const lines = ["Demo complete.", "Press Spacebar to start the real task"];
        const lineHeight = 50; 
        const startY = window.canvas.height/2 - (2 * lineHeight);

        window.ctx.fillStyle = "#FFFFFF";
        lines.forEach((text, i) => {
            window.ctx.fillText(
            text,
            window.canvas.width/2,
            startY + i * lineHeight
            );
        });

        $(document).off('keydown.waitForSpace');
        $(document).on('keydown.waitForSpace', function onKey(e) {
            if (e.keyCode !== 32) return; 
            $(document).off('keydown.waitForSpace');
            runSession(); 
        });
        }

    function clearCanvas(){
        window.ctx.fillStyle = "#FFFFFF";
        window.ctx.clearRect(0, 0, window.canvas.width, window.canvas.height);
    }
    function writeText(text, color = "#FFFFFF"){
        clearCanvas();
        window.ctx.fillStyle = color;
        window.ctx.fillText(text, window.canvas.width/2, window.canvas.height/2);
    }
    function setup(){
        window.canvas = document.getElementById("experiment");
        window.ctx = window.canvas.getContext("2d");
        window.ctx.font = "bold 48px Arial";
        window.ctx.textAlign = "center";
    }

    function instructions() {
        clearCanvas();

        const lines = [
            "Press G for green",
            "Press B for blue",
            "Press R for red",
            "You'll first do a short demo (6 trials)",
            "Press Spacebar to start the demo"
        ];
        const lineHeight = 50; 
        const startY = window.canvas.height/2 - (2 * lineHeight);

        window.ctx.fillStyle = "#FFFFFF";
        lines.forEach((text, i) => {
            window.ctx.fillText(
            text,
            window.canvas.width/2,
            startY + i * lineHeight
            );
        });

        $(document).off('keydown.waitForSpace');
        $(document).on('keydown.waitForSpace', function onKey(e) {
        if (e.keyCode !== 32) return; 
        $(document).off('keydown.waitForSpace');
        runDemoSession();
        });
        }

    function main(){
        setup();
        instructions();
    }

    $(window).on('load', main);
</script>


    </body>
</html>